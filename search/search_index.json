{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Oolong Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotlin multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a render function which is implemented by each frontend. An example Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) Msg . Decrement -> model . copy ( count = model . count - 1 ) } to none () } val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } See it in action Initialize an Oolong runtime by supplying your init , update , and view functions as well as a render function from the host platform. Press the play button below to run the example. import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.runBlocking import oolong.Dispatch import oolong.Dispose import oolong.Effect import oolong.Oolong import oolong.effect.none fun < Model : Any , Msg : Any , Props : Any > CoroutineScope . runtime ( init : () -> Pair < Model , Effect < Msg >> , update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> , view : ( Model ) -> Props , render : ( Props , Dispatch < Msg > ) -> Any? , ): Dispose = Oolong . runtime ( init , update , view , render , coroutineContext , coroutineContext , coroutineContext ) data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) Msg . Decrement -> model . copy ( count = model . count - 1 ) } to none () } val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } fun main () { runBlocking { //sampleStart val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> // Print the current count println ( \"count: ${ props . count } \" ) // Dispatch Msg.Increment if less than 3 if ( props . count < 3 ) { props . increment ( dispatch ) } } runtime ( init , update , view , render ) //sampleEnd } }","title":"Overview"},{"location":"#oolong","text":"Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotlin multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a render function which is implemented by each frontend.","title":"Oolong"},{"location":"#an-example","text":"Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) Msg . Decrement -> model . copy ( count = model . count - 1 ) } to none () } val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) }","title":"An example"},{"location":"#see-it-in-action","text":"Initialize an Oolong runtime by supplying your init , update , and view functions as well as a render function from the host platform. Press the play button below to run the example. import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.runBlocking import oolong.Dispatch import oolong.Dispose import oolong.Effect import oolong.Oolong import oolong.effect.none fun < Model : Any , Msg : Any , Props : Any > CoroutineScope . runtime ( init : () -> Pair < Model , Effect < Msg >> , update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> , view : ( Model ) -> Props , render : ( Props , Dispatch < Msg > ) -> Any? , ): Dispose = Oolong . runtime ( init , update , view , render , coroutineContext , coroutineContext , coroutineContext ) data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit ) val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) Msg . Decrement -> model . copy ( count = model . count - 1 ) } to none () } val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } fun main () { runBlocking { //sampleStart val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> // Print the current count println ( \"count: ${ props . count } \" ) // Dispatch Msg.Increment if less than 3 if ( props . count < 3 ) { props . increment ( dispatch ) } } runtime ( init , update , view , render ) //sampleEnd } }","title":"See it in action"},{"location":"changelog/","text":"Changelog Unreleased Added Add a next builder function. 2.1.0 - 2020-09-28 Added Add a runtime overload which combines view and render . Update Kotlin to 1.4.10 Changed CoroutineDispatcher replaced with CoroutineContext in runtime builder. Dispatch deprecated in favor of Job . oolong.Oolong.runtime deprecated in favor of oolong.runtime . disposableEffect deprecated. Allow incoming types to be nullable. Deprecate Next , Init , Update , View , and Render in preference of underlying types. 2.0.7 - 2020-08-17 Added Update Kotlin to 1.4.0 Update Kotlin Coroutines to 1.3.9 2.0.6 - 2020-06-30 Fixed Maven Central artifacts. 2.0.5 - 2020-06-10 Added Update Kotlin Coroutines to 1.3.7 2.0.4 - 2020-05-17 Added Update Kotlin Coroutines to 1.3.6 Add samples link to readme Fixed Allow dispatcher specification. 2.0.3 - 2020-04-25 Added Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5 Removed Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function. 2.0.2 - 2020-01-08 Added Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3 Removed Samples moved to https://github.com/oolong-kt/oolong-samples 2.0.1 - 2019-06-20 Added Update Kotlin to 1.3.40 Changed Remove default arguments for Runtime constructor 2.0.0 - 2019-05-31 Added Add samples Changed Move to oolong-kt org and update packages Change core types from classes to functions 1.0.0 - 2018-08-01 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"Add a next builder function.","title":"Added"},{"location":"changelog/#210-2020-09-28","text":"","title":"2.1.0 - 2020-09-28"},{"location":"changelog/#added_1","text":"Add a runtime overload which combines view and render . Update Kotlin to 1.4.10","title":"Added"},{"location":"changelog/#changed","text":"CoroutineDispatcher replaced with CoroutineContext in runtime builder. Dispatch deprecated in favor of Job . oolong.Oolong.runtime deprecated in favor of oolong.runtime . disposableEffect deprecated. Allow incoming types to be nullable. Deprecate Next , Init , Update , View , and Render in preference of underlying types.","title":"Changed"},{"location":"changelog/#207-2020-08-17","text":"","title":"2.0.7 - 2020-08-17"},{"location":"changelog/#added_2","text":"Update Kotlin to 1.4.0 Update Kotlin Coroutines to 1.3.9","title":"Added"},{"location":"changelog/#206-2020-06-30","text":"","title":"2.0.6 - 2020-06-30"},{"location":"changelog/#fixed","text":"Maven Central artifacts.","title":"Fixed"},{"location":"changelog/#205-2020-06-10","text":"","title":"2.0.5 - 2020-06-10"},{"location":"changelog/#added_3","text":"Update Kotlin Coroutines to 1.3.7","title":"Added"},{"location":"changelog/#204-2020-05-17","text":"","title":"2.0.4 - 2020-05-17"},{"location":"changelog/#added_4","text":"Update Kotlin Coroutines to 1.3.6 Add samples link to readme","title":"Added"},{"location":"changelog/#fixed_1","text":"Allow dispatcher specification.","title":"Fixed"},{"location":"changelog/#203-2020-04-25","text":"","title":"2.0.3 - 2020-04-25"},{"location":"changelog/#added_5","text":"Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5","title":"Added"},{"location":"changelog/#removed","text":"Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function.","title":"Removed"},{"location":"changelog/#202-2020-01-08","text":"","title":"2.0.2 - 2020-01-08"},{"location":"changelog/#added_6","text":"Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3","title":"Added"},{"location":"changelog/#removed_1","text":"Samples moved to https://github.com/oolong-kt/oolong-samples","title":"Removed"},{"location":"changelog/#201-2019-06-20","text":"","title":"2.0.1 - 2019-06-20"},{"location":"changelog/#added_7","text":"Update Kotlin to 1.3.40","title":"Added"},{"location":"changelog/#changed_1","text":"Remove default arguments for Runtime constructor","title":"Changed"},{"location":"changelog/#200-2019-05-31","text":"","title":"2.0.0 - 2019-05-31"},{"location":"changelog/#added_8","text":"Add samples","title":"Added"},{"location":"changelog/#changed_2","text":"Move to oolong-kt org and update packages Change core types from classes to functions","title":"Changed"},{"location":"changelog/#100-2018-08-01","text":"Initial release","title":"1.0.0 - 2018-08-01"},{"location":"guide/core-concepts/","text":"Core Concepts Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model. Model The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 ) Update Messages Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed class. This allows us to use an exhaustive list of types when interpreting messages. sealed class Msg { object Increment : Msg () object Decrement : Msg () } Update function The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed classes. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) to none () Msg . Decrement -> model . copy ( count = model . count - 1 ) to none () } } View The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props . View properties There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is message generators. Your rendering code will know how to display properties and dispatch messages created from generators. If you are only targetting one platform, then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit ) View function The view function, as mentioned above, takes the current state its argument and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } Putting it all together Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties. Initialization function To get the runtime loop started, we first need to know what the initial state is. We do this by definiting an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desireable to define defaults in the model class and simply return a new instance from the init function. val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () } Render function We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> // Platform specific rendering countLabel . text = \" ${ props . count } \" incrementButton . setOnClickListener { dispatch ( props . increment ()) } decrementButton . setOnClickListener { dispatch ( props . decrement ()) } } Runtime The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render )","title":"Core Concepts"},{"location":"guide/core-concepts/#core-concepts","text":"Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model.","title":"Core Concepts"},{"location":"guide/core-concepts/#model","text":"The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 )","title":"Model"},{"location":"guide/core-concepts/#update","text":"","title":"Update"},{"location":"guide/core-concepts/#messages","text":"Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed class. This allows us to use an exhaustive list of types when interpreting messages. sealed class Msg { object Increment : Msg () object Decrement : Msg () }","title":"Messages"},{"location":"guide/core-concepts/#update-function","text":"The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed classes. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) to none () Msg . Decrement -> model . copy ( count = model . count - 1 ) to none () } }","title":"Update function"},{"location":"guide/core-concepts/#view","text":"The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props .","title":"View"},{"location":"guide/core-concepts/#view-properties","text":"There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is message generators. Your rendering code will know how to display properties and dispatch messages created from generators. If you are only targetting one platform, then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : ( Dispatch < Msg > ) -> Unit , val decrement : ( Dispatch < Msg > ) -> Unit )","title":"View properties"},{"location":"guide/core-concepts/#view-function","text":"The view function, as mentioned above, takes the current state its argument and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : ( Model ) -> Props = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) }","title":"View function"},{"location":"guide/core-concepts/#putting-it-all-together","text":"Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties.","title":"Putting it all together"},{"location":"guide/core-concepts/#initialization-function","text":"To get the runtime loop started, we first need to know what the initial state is. We do this by definiting an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desireable to define defaults in the model class and simply return a new instance from the init function. val init : () -> Pair < Model , Effect < Msg >> = { Model () to none () }","title":"Initialization function"},{"location":"guide/core-concepts/#render-function","text":"We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> // Platform specific rendering countLabel . text = \" ${ props . count } \" incrementButton . setOnClickListener { dispatch ( props . increment ()) } decrementButton . setOnClickListener { dispatch ( props . decrement ()) } }","title":"Render function"},{"location":"guide/core-concepts/#runtime","text":"The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render )","title":"Runtime"},{"location":"guide/rendering/","text":"Rendering Coming soon!","title":"Rendering"},{"location":"guide/rendering/#rendering","text":"Coming soon!","title":"Rendering"},{"location":"guide/side-effects/","text":"Side Effects A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect < Msg > { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect < Msg > { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"guide/side-effects/#side-effects","text":"A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect < Msg > { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect < Msg > { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"oolong/","text":"oolong Packages Name Summary (common) oolong (common) oolong.dispatch (common) oolong.effect (common) oolong.next Index All Types","title":"API Reference"},{"location":"oolong/#packages","text":"Name Summary (common) oolong (common) oolong.dispatch (common) oolong.effect (common) oolong.next","title":"Packages"},{"location":"oolong/#index","text":"All Types","title":"Index"},{"location":"oolong/alltypes/","text":"All Types Name Summary (common) oolong.Dispatch A function to dispatch a Msg to the runtime in the runtime context. |(common) oolong.Effect A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context.","title":"All Types - Oolong"},{"location":"oolong/alltypes/#all-types","text":"Name Summary (common)","title":"All Types"},{"location":"oolong/alltypes/#oolongdispatch","text":"A function to dispatch a Msg to the runtime in the runtime context. |(common)","title":"oolong.Dispatch"},{"location":"oolong/alltypes/#oolongeffect","text":"A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context.","title":"oolong.Effect"},{"location":"oolong/oolong/","text":"oolong / oolong Package oolong Types Name Summary (common) Dispatch A function to dispatch a Msg to the runtime in the runtime context. typealias Dispatch<Msg> = (Msg) -> Unit (common) Effect A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context. typealias Effect<Msg> = suspend CoroutineScope.( Dispatch <Msg>) -> Any ? Functions Name Summary (common) effect Effect builder function. fun <Msg> effect(block: Effect <Msg>): Effect <Msg> (common) init Init builder function. fun <Model, Msg> init(block: () -> Pair <Model, Effect <Msg>>): () -> Pair <Model, Effect <Msg>> (common) render Render builder function. fun <Props, Msg> render(block: (Props, Dispatch <Msg>) -> Any ?): (Props, Dispatch <Msg>) -> Any ? (common) runtime Create a runtime. fun <Model, Msg> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job fun <Model, Msg, Props> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model) -> Props, render: (Props, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (common) update Update builder function. fun <Model, Msg> update(block: (Msg, Model) -> Pair <Model, Effect <Msg>>): (Msg, Model) -> Pair <Model, Effect <Msg>> (common) view View builder function. fun <Model, Props> view(block: (Model) -> Props): (Model) -> Props","title":"Package oolong - Oolong"},{"location":"oolong/oolong/#package-oolong","text":"","title":"Package oolong"},{"location":"oolong/oolong/#types","text":"Name Summary (common) Dispatch A function to dispatch a Msg to the runtime in the runtime context. typealias Dispatch<Msg> = (Msg) -> Unit (common) Effect A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context. typealias Effect<Msg> = suspend CoroutineScope.( Dispatch <Msg>) -> Any ?","title":"Types"},{"location":"oolong/oolong/#functions","text":"Name Summary (common) effect Effect builder function. fun <Msg> effect(block: Effect <Msg>): Effect <Msg> (common) init Init builder function. fun <Model, Msg> init(block: () -> Pair <Model, Effect <Msg>>): () -> Pair <Model, Effect <Msg>> (common) render Render builder function. fun <Props, Msg> render(block: (Props, Dispatch <Msg>) -> Any ?): (Props, Dispatch <Msg>) -> Any ? (common) runtime Create a runtime. fun <Model, Msg> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job fun <Model, Msg, Props> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model) -> Props, render: (Props, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (common) update Update builder function. fun <Model, Msg> update(block: (Msg, Model) -> Pair <Model, Effect <Msg>>): (Msg, Model) -> Pair <Model, Effect <Msg>> (common) view View builder function. fun <Model, Props> view(block: (Model) -> Props): (Model) -> Props","title":"Functions"},{"location":"oolong/oolong/-dispatch/","text":"oolong / oolong / Dispatch Dispatch (common) typealias Dispatch<Msg> = (Msg) -> Unit (source) A function to dispatch a Msg to the runtime in the runtime context.","title":"Dispatch - Oolong"},{"location":"oolong/oolong/-dispatch/#dispatch","text":"(common) typealias Dispatch<Msg> = (Msg) -> Unit (source) A function to dispatch a Msg to the runtime in the runtime context.","title":"Dispatch"},{"location":"oolong/oolong/-effect/","text":"oolong / oolong / Effect Effect (common) typealias Effect<Msg> = suspend CoroutineScope.( Dispatch <Msg>) -> Any ? (source) A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context.","title":"Effect - Oolong"},{"location":"oolong/oolong/-effect/#effect","text":"(common) typealias Effect<Msg> = suspend CoroutineScope.( Dispatch <Msg>) -> Any ? (source) A function to run a side-effect in the effect context. Provides a Dispatch function to dispatch a Msg to the runtime in the runtime context.","title":"Effect"},{"location":"oolong/oolong/effect/","text":"oolong / oolong / effect effect (common) fun <Msg> effect(block: Effect <Msg>): Effect <Msg> (source) Effect builder function.","title":"effect - Oolong"},{"location":"oolong/oolong/effect/#effect","text":"(common) fun <Msg> effect(block: Effect <Msg>): Effect <Msg> (source) Effect builder function.","title":"effect"},{"location":"oolong/oolong/init/","text":"oolong / oolong / init init (common) fun <Model, Msg> init(block: () -> Pair <Model, Effect <Msg>>): () -> Pair <Model, Effect <Msg>> (source) Init builder function.","title":"init - Oolong"},{"location":"oolong/oolong/init/#init","text":"(common) fun <Model, Msg> init(block: () -> Pair <Model, Effect <Msg>>): () -> Pair <Model, Effect <Msg>> (source) Init builder function.","title":"init"},{"location":"oolong/oolong/render/","text":"oolong / oolong / render render (common) fun <Props, Msg> render(block: (Props, Dispatch <Msg>) -> Any ?): (Props, Dispatch <Msg>) -> Any ? (source) Render builder function.","title":"render - Oolong"},{"location":"oolong/oolong/render/#render","text":"(common) fun <Props, Msg> render(block: (Props, Dispatch <Msg>) -> Any ?): (Props, Dispatch <Msg>) -> Any ? (source) Render builder function.","title":"render"},{"location":"oolong/oolong/runtime/","text":"oolong / oolong / runtime runtime (common) @JvmOverloads fun <Model, Msg> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (source) @JvmOverloads fun <Model, Msg, Props> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model) -> Props, render: (Props, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (source) Create a runtime.","title":"runtime - Oolong"},{"location":"oolong/oolong/runtime/#runtime","text":"(common) @JvmOverloads fun <Model, Msg> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (source) @JvmOverloads fun <Model, Msg, Props> runtime(init: () -> Pair <Model, Effect <Msg>>, update: (Msg, Model) -> Pair <Model, Effect <Msg>>, view: (Model) -> Props, render: (Props, Dispatch <Msg>) -> Any ?, runtimeContext: CoroutineContext = Dispatchers.Default, renderContext: CoroutineContext = Dispatchers.Main, effectContext: CoroutineContext = Dispatchers.Default): Job (source) Create a runtime.","title":"runtime"},{"location":"oolong/oolong/update/","text":"oolong / oolong / update update (common) fun <Model, Msg> update(block: (Msg, Model) -> Pair <Model, Effect <Msg>>): (Msg, Model) -> Pair <Model, Effect <Msg>> (source) Update builder function.","title":"update - Oolong"},{"location":"oolong/oolong/update/#update","text":"(common) fun <Model, Msg> update(block: (Msg, Model) -> Pair <Model, Effect <Msg>>): (Msg, Model) -> Pair <Model, Effect <Msg>> (source) Update builder function.","title":"update"},{"location":"oolong/oolong/view/","text":"oolong / oolong / view view (common) fun <Model, Props> view(block: (Model) -> Props): (Model) -> Props (source) View builder function.","title":"view - Oolong"},{"location":"oolong/oolong/view/#view","text":"(common) fun <Model, Props> view(block: (Model) -> Props): (Model) -> Props (source) View builder function.","title":"view"},{"location":"oolong/oolong.dispatch/","text":"oolong / oolong.dispatch Package oolong.dispatch Functions Name Summary (common) contramap Contramap from Dispatch of A to Dispatch of B fun <A, B> contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B>","title":"Package oolong.dispatch - Oolong"},{"location":"oolong/oolong.dispatch/#package-oolongdispatch","text":"","title":"Package oolong.dispatch"},{"location":"oolong/oolong.dispatch/#functions","text":"Name Summary (common) contramap Contramap from Dispatch of A to Dispatch of B fun <A, B> contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B>","title":"Functions"},{"location":"oolong/oolong.dispatch/contramap/","text":"oolong / oolong.dispatch / contramap contramap (common) fun <A, B> contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B> (source) Contramap from Dispatch of A to Dispatch of B See: https://oolong-kt.org/recipes/navigation/","title":"contramap - Oolong"},{"location":"oolong/oolong.dispatch/contramap/#contramap","text":"(common) fun <A, B> contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B> (source) Contramap from Dispatch of A to Dispatch of B See: https://oolong-kt.org/recipes/navigation/","title":"contramap"},{"location":"oolong/oolong.effect/","text":"oolong / oolong.effect Package oolong.effect Functions Name Summary (common) batch Compose effects into a single Effect . fun <Msg> batch(vararg effects: Effect <Msg>): Effect <Msg> fun <Msg> batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (common) map Map effect of type A to Effect of B using f . fun <A, B> map(effect: Effect <A>, f: (A) -> B): Effect <B> (common) none Create an empty Effect . fun <Msg> none(): Effect <Msg>","title":"Package oolong.effect - Oolong"},{"location":"oolong/oolong.effect/#package-oolongeffect","text":"","title":"Package oolong.effect"},{"location":"oolong/oolong.effect/#functions","text":"Name Summary (common) batch Compose effects into a single Effect . fun <Msg> batch(vararg effects: Effect <Msg>): Effect <Msg> fun <Msg> batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (common) map Map effect of type A to Effect of B using f . fun <A, B> map(effect: Effect <A>, f: (A) -> B): Effect <B> (common) none Create an empty Effect . fun <Msg> none(): Effect <Msg>","title":"Functions"},{"location":"oolong/oolong.effect/batch/","text":"oolong / oolong.effect / batch batch (common) fun <Msg> batch(vararg effects: Effect <Msg>): Effect <Msg> (source) fun <Msg> batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (source) Compose effects into a single Effect .","title":"batch - Oolong"},{"location":"oolong/oolong.effect/batch/#batch","text":"(common) fun <Msg> batch(vararg effects: Effect <Msg>): Effect <Msg> (source) fun <Msg> batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (source) Compose effects into a single Effect .","title":"batch"},{"location":"oolong/oolong.effect/map/","text":"oolong / oolong.effect / map map (common) fun <A, B> map(effect: Effect <A>, f: (A) -> B): Effect <B> (source) Map effect of type A to Effect of B using f .","title":"map - Oolong"},{"location":"oolong/oolong.effect/map/#map","text":"(common) fun <A, B> map(effect: Effect <A>, f: (A) -> B): Effect <B> (source) Map effect of type A to Effect of B using f .","title":"map"},{"location":"oolong/oolong.effect/none/","text":"oolong / oolong.effect / none none (common) fun <Msg> none(): Effect <Msg> (source) Create an empty Effect .","title":"none - Oolong"},{"location":"oolong/oolong.effect/none/#none","text":"(common) fun <Msg> none(): Effect <Msg> (source) Create an empty Effect .","title":"none"},{"location":"oolong/oolong.next/","text":"oolong / oolong.next Package oolong.next Functions Name Summary (common) bimap Transform next of type A to Effect of type B to Pair of type C to Effect of type D using fa and fb . fun <A, B, C, D> bimap(next: Pair <A, Effect <B>>, fa: (A) -> C, fb: (B) -> D): Pair <C, Effect <D>> (common) next Create a pair of model to effect where effect defaults to none . fun <Model, Msg> next(model: Model, effect: Effect <Msg> = none()): Pair <Model, Effect <Msg>>","title":"Package oolong.next - Oolong"},{"location":"oolong/oolong.next/#package-oolongnext","text":"","title":"Package oolong.next"},{"location":"oolong/oolong.next/#functions","text":"Name Summary (common) bimap Transform next of type A to Effect of type B to Pair of type C to Effect of type D using fa and fb . fun <A, B, C, D> bimap(next: Pair <A, Effect <B>>, fa: (A) -> C, fb: (B) -> D): Pair <C, Effect <D>> (common) next Create a pair of model to effect where effect defaults to none . fun <Model, Msg> next(model: Model, effect: Effect <Msg> = none()): Pair <Model, Effect <Msg>>","title":"Functions"},{"location":"oolong/oolong.next/bimap/","text":"oolong / oolong.next / bimap bimap (common) fun <A, B, C, D> bimap(next: Pair <A, Effect <B>>, fa: (A) -> C, fb: (B) -> D): Pair <C, Effect <D>> (source) Transform next of type A to Effect of type B to Pair of type C to Effect of type D using fa and fb .","title":"bimap - Oolong"},{"location":"oolong/oolong.next/bimap/#bimap","text":"(common) fun <A, B, C, D> bimap(next: Pair <A, Effect <B>>, fa: (A) -> C, fb: (B) -> D): Pair <C, Effect <D>> (source) Transform next of type A to Effect of type B to Pair of type C to Effect of type D using fa and fb .","title":"bimap"},{"location":"oolong/oolong.next/next/","text":"oolong / oolong.next / next next (common) fun <Model, Msg> next(model: Model, effect: Effect <Msg> = none()): Pair <Model, Effect <Msg>> (source) Create a pair of model to effect where effect defaults to none .","title":"next - Oolong"},{"location":"oolong/oolong.next/next/#next","text":"(common) fun <Model, Msg> next(model: Model, effect: Effect <Msg> = none()): Pair <Model, Effect <Msg>> (source) Create a pair of model to effect where effect defaults to none .","title":"next"},{"location":"recipes/isolation/","text":"Isolation Coming soon!","title":"Isolation"},{"location":"recipes/isolation/#isolation","text":"Coming soon!","title":"Isolation"},{"location":"recipes/navigation/","text":"Navigation Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail . Data Structures The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model consists of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Pair < Model , Effect < Msg >> ): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () } Functions Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Pair<A, Effect<B>> to an instance of Pair<C, Effect<D>> . We're going to use List as our initial screen, so in this case we're bimapping from an instance of Pair<List.Model , Effect<List.Msg >> to an instance of Pair<Model, Effect<Msg>> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : () -> Pair < Model , Effect < Msg >> = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : ( Model ) -> Props = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } } Navigating With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigation"},{"location":"recipes/navigation/#navigation","text":"Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail .","title":"Navigation"},{"location":"recipes/navigation/#data-structures","text":"The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model consists of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Pair < Model , Effect < Msg >> ): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () }","title":"Data Structures"},{"location":"recipes/navigation/#functions","text":"Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Pair<A, Effect<B>> to an instance of Pair<C, Effect<D>> . We're going to use List as our initial screen, so in this case we're bimapping from an instance of Pair<List.Model , Effect<List.Msg >> to an instance of Pair<Model, Effect<Msg>> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : () -> Pair < Model , Effect < Msg >> = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : ( Msg , Model ) -> Pair < Model , Effect < Msg >> = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : ( Model ) -> Props = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : ( Props , Dispatch < Msg > ) -> Any? = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } }","title":"Functions"},{"location":"recipes/navigation/#navigating","text":"With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigating"},{"location":"samples/official/","text":"Counter A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter Random A random number generator demonstrating update effects. https://github.com/oolong-kt/samples/tree/master/samples/random Time A time display demonstrating init effects. https://github.com/oolong-kt/samples/tree/master/samples/time TodoMVC An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"Official"},{"location":"samples/official/#counter","text":"A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter","title":"Counter"},{"location":"samples/official/#random","text":"A random number generator demonstrating update effects. https://github.com/oolong-kt/samples/tree/master/samples/random","title":"Random"},{"location":"samples/official/#time","text":"A time display demonstrating init effects. https://github.com/oolong-kt/samples/tree/master/samples/time","title":"Time"},{"location":"samples/official/#todomvc","text":"An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"TodoMVC"},{"location":"samples/third-party/","text":"Lambda news A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news Dice A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Third-party"},{"location":"samples/third-party/#lambda-news","text":"A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news","title":"Lambda news"},{"location":"samples/third-party/#dice","text":"A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Dice"}]}